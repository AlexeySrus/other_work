http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html
перевод:
https://habrahabr.ru/post/120562/
Хэширование картинки происходит быстро, достаточно один раз пройти по всей базе для составления
хэш-кодов изображений. Далее можно составить хэш-таблицу для поиска со сложностью O(1).
Для достижения хоть какой-то точности необходимо предварительно пройти по изображению детектором границ Кенни (далее с помощью phash),
и всё-равно точность оставляет желать лучшего, метод даст много лишних кандидатов. Можно из выборки похожих изображений
далее искать более подходящие, фильтруя также и по цвету.

https://github.com/paucarre/tiefvision
Решает задачу кластеризации и нахождения зависимостей между объектами.
Данный проект очень схож с тем, что требуется делать.
Автор показывает работу нейронной сети "AlexNet" на примере классификации стилей одежды (текстуры, цвета).
Насколько я понял, при нахождении схожих изображений, переданное изображение переводится в промежуточную структуру, содержащую
также и естественные описания, пример из синтезированных зависимостей
(файл: tiefvision/src/torch/1-split-encoder-classifier/synset_words.txt): 
n02408429 water buffalo, water ox, Asiatic buffalo, Bubalus bubalis
n02410509 bison
n02412080 ram, tup
Далее находятся схожие по k-соседям.
Написан почти весь проект на скриптовом языке Lua. Требует работу с БД(H2), нейронная сеть реализованна на CUDA
с неизвестной версией и неизвестными опорными библеотеками(CuDNN, ...) или же писалось всё с нуля.

https://github.com/freespace/mactorii

вложенный файл sravnenie-metodov-poiska-izobrazheniya-po-soderzhaniyu.pdf
Пространственное распределение цветов вычисляется достаточно быстро, и достаточно один раз вычислить его
для набора хранимых изображений. Данный подход, как и в случае хэширования не позволяет подбирать
схожие и по цвету текстуры и поэтому понадобится дополнительная выборка по цветовому сходству.

https://github.com/BVLC/caffe
Или же можно использовать фреймворки глубинного обучения, чтобы кластеризовать набор изображений
и далее производить классификацию поданных изображений уже на основе выделенных классов. Может требовать много ресурсов(CPU).

https://habrahabr.ru/post/211773/
Альтернативой может стать индексация изображений по ключевым точкам.
В первый раз нахождение точек может стать очень затратной по времени процедурой, но далее сравнение будет идти по 64-битному
числу (по расстоянию Хэмминга) или можно не хэшировать дескрипторы, что увеличит точность, но сложность поиска возрастёт
(используя двоичное дерево поиска(BST) O(log(n)).
